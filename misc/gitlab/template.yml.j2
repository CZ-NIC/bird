{#

Do edit this file by hand. The following header will be placed
into .gitlab-ci.yml.

#}
###########################################################
#####                                                 #####
#####       DO  NOT  EDIT  THIS  FILE  BY  HAND       #####
#####                                                 #####
###########################################################
#####                                                 #####
##### This file is autogenerated from misc/gitlab/.   #####
##### Edit those files and run `make gitlab` instead. #####
#####                                                 #####
###########################################################

variables:
  DEBIAN_FRONTEND: noninteractive
  LC_ALL: C.UTF-8
  GIT_STRATEGY: fetch
  DOCKER_CMD: docker --config="$HOME/.docker/$CI_JOB_ID/"
  IMG_BASE: registry.nic.cz/labs/bird
  TOOLS_DIR: /home/gitlab-runner/bird-tools
  PBUILDER_DIR: /home/gitlab-runner/pbuilder
  STAYRTR_BINARY: /usr/local/bin/stayrtr

stages:
  - consistency
  - image
  - build
  - pkg
  - install
  - test

## Common rules
# Run for stable branches
.if-stable: &if-stable

# Do run for tags
.if-tag: &if-tag

# Never run for tags
.never-tag: &never-tag
  if: $CI_COMMIT_TAG
  when: never

{% macro rwhen(parts, kind) %}when: {% if pipelines[kind].short in parts %}always{% else %}never{% endif %}{% endmacro %}
{% macro job(name, parts) %}
{{ name }}:
  rules:
    # Explicit job triggers from the API
    - if: '${trigger-job-{{ name }}} =~ /^(yes|true|trigger)$/'
      when: always
    - if: '${trigger-job-{{ name }}} =~ /^(no|false|block)$/'
      when: never

    # Explicit pipeline kind override from the API
{% for kind in pipelines %}
    - if: '${pipeline-kind} == "{{ kind }}"'
      {{ rwhen(parts, kind) }}
{%- endfor %}

    # Run only explicitly named jobs
    - if: '${pipeline-kind} == "explicit"'
      when: never

    # Explicit job triggers from the commit message
    - if: '$CI_COMMIT_MESSAGE =~ /^CI-Job-Trigger: {{ name }}$/mi'
      when: always
    - if: '$CI_COMMIT_MESSAGE =~ /^CI-Job-Block: {{ name }}$/mi'
      when: never

    # Explicit pipeline kind override from the commit message
{% for kind in pipelines %}
    - if: '$CI_COMMIT_MESSAGE =~ /^CI-Pipeline-Kind: {{ kind }}$/mi'
      {{ rwhen(parts, kind) }}
{%- endfor %}

    # Ignore WIP commits
    - if: '$CI_COMMIT_MESSAGE =~ /^(fixup! )*WIP/'
      when: never

{% for kind in pipelines %}
    # {% if pipelines[kind].short in parts %}Run{% else %}Ignore{% endif %} {{ pipelines[kind].desc }}
    - if: '{{ pipelines[kind].cond }}'
      {{ rwhen(parts, kind) }}
{%- endfor %}

    # Do not run by default
    - when: never
{% endmacro %}

## Consistency checks for stable branches
{{ job("commit-messages", "ST") }}
  stage: consistency
  image: registry.nic.cz/labs/bird:docbuilder
  script:
  - tools/git-check-commits

## Tag check
{{ job("tag-collect", "T") }}
  stage: consistency
  image: registry.nic.cz/labs/bird:docbuilder
  script:
  - python3 -m venv venv
  - . venv/bin/activate
  - pip3 install requests
  - tools/git-check-tag-local $CI_COMMIT_TAG
  - tools/git-check-tag-ci $CI_COMMIT_SHA
  artifacts:
    paths:
      - obj/doc/bird-singlepage.html
      - bird-*.tar.gz
      - pkg/pkgs/*
      - pkg/srcpkgs/*

############################
## Docker builder rebuild ##
############################
# We are running all the build / packaging tests in Dockers (unless otherwise)
# and these are rules to build these docker images. These are expensive to run
# and should run only if needed.
#
# Modify the appropriate dockerfile to rebuild these images

.docker: &docker-build
  stage: image
  script:
  - $DOCKER_CMD login -u gitlab-ci-token -p $CI_JOB_TOKEN registry.nic.cz
  # Make sure we refresh the base image if it updates (eg. security updates, etc)
  # If we do just the build, cache is always reused and the freshness of the
  # base image is never checked. However, pull always asks and updates the
  # image only if it changed â€’ therefore, the cache is used unless there's a
  # change.
  - $DOCKER_CMD pull `sed -ne 's/^FROM //p' "misc/docker/$IMG_NAME/Dockerfile"`
  - $DOCKER_CMD build -t "bird:$IMG_NAME" "misc/docker/$IMG_NAME"
  - $DOCKER_CMD tag "bird:$IMG_NAME" "$IMG_BASE:$IMG_NAME"
  - $DOCKER_CMD push "$IMG_BASE:$IMG_NAME"
  after_script:
  - rm -f "$HOME/.docker/$CI_JOB_ID/" # cleanup the credentials
  tags:
  # That's Docker in Docker
  - dind

{% for docker in [ { "name": "docbuilder", "arch": "amd64" } ] + distros %}
{%- if docker.arch in ("amd64", "i386") %}
{{ job("docker-" + docker["name"], "") }}:
  variables:
    IMG_NAME: "{{ docker["name"] }}"
  <<: *docker-build
{%- endif -%}
{% endfor %}

#####################################################
## Linux distro build tests inside Docker builders ##
#####################################################

## Build stage
#
# Now we compile and run unit tests ... in every single distribution.
# Every task needs its docker, see above.

.build: &build-base
  stage: build
  script:
    - if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then export BRANCH=mergerequest-$CI_MERGE_REQUEST_IID; else export BRANCH=$CI_COMMIT_BRANCH; fi
    - tools/version && ( echo -n "BIRD version "; tools/version ) > version-expected
    - |
      STABLE_VERSION="`cat VERSION`"
      if [ "$CI_COMMIT_MESSAGE" == "NEWS and version update
      " ]; then
        if [ "${STABLE_VERSION}" == "`tools/version`" ]; then
          echo "Stable version precheck OK"
        else
          echo "Stable version discrepancy: $STABLE_VERSION vs. $(tools/version)"
          exit 1
        fi
      else
        if grep -qF "BIRD version ${STABLE_VERSION}+branch" version-expected; then
          true
        else
          echo -n "Commit $CI_COMMIT_SHA message $CI_COMMIT_MESSAGE expects version "
          cat version-expected
          exit 1
        fi
      fi
    - autoreconf
    - ./configure CPPFLAGS="$CPPFLAGS" LDFLAGS="$LDFLAGS" $CONFIGURE_OPTIONS
    # Detect which make is available
    - MAKE=make
    - which gmake 2>/dev/null >/dev/null && MAKE=gmake
    - $MAKE
    - $MAKE check
    # Build docs when tools are available
    - if which linuxdoc pdflatex sgmlsasp >/dev/null ; then $MAKE docs ; fi
    # Check that the reported version is the right one
    - ./bird --version |& tee obj/version-built
    - diff obj/version-built version-expected

.build-docker-linux-amd64: &build-docker-linux-amd64
  <<: *build-base
  tags:
    - docker
    - linux
    - amd64

{% for dist in distros %}
{%- if dist.arch in ("amd64", "i386") %}
{{ job("build-" + dist["name"], "STD") }}
  <<: *build-docker-linux-amd64
  needs:
    - job: docker-{{ dist["name"] }}
      optional: true
  image: registry.nic.cz/labs/bird:{{ dist["name"] }}
{%- if 'variables' in dist %}
  variables:
{{ dist["variables"] | to_yaml | indent(4, true) }}
{%- endif %}
{%- endif -%}
{% endfor %}

#######################################################
## A special task for preparing the release archives ##
#######################################################
{{ job("build-release", "STD") }}
  image: registry.nic.cz/labs/bird:docbuilder
  needs: 
    - job: docker-docbuilder
      optional: true
  stage: build
  tags:
    - docker
    - linux
  script:
    - if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then export BRANCH=mergerequest-$CI_MERGE_REQUEST_IID; else export BRANCH=$CI_COMMIT_BRANCH; fi
    - autoreconf
    - ./configure --with-protocols= --disable-client
    - make obj/doc/bird-singlepage.html
    - tools/make-archive
  artifacts:
    paths:
      - obj/doc/bird-singlepage.html
      - bird-*.tar.gz
    expire_in: 1 day
  rules:
  - *never-wip
  - *never-tag
  - when: always

# Packaging rules
# As we support some ancient versions of different distributions,
# we need to keep several different machineries. It's not so bad
# but it's bad nevertheless.
#
# We do NOT build separate documentation packages in these rules.

.pkg-deb: &pkg-deb
  stage: pkg
  script:
    - if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then export BRANCH=mergerequest-$CI_MERGE_REQUEST_IID; else export BRANCH=$CI_COMMIT_BRANCH; fi
    - tools/make-debian -BS
  artifacts:
    paths:
      - pkg/pkgs/*
      - pkg/srcpkgs/*
  rules:
  - *never-wip
  - *never-tag
  - when: always

.pkg-deb-legacy: &pkg-deb-legacy
  stage: pkg
  script:
    - if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then export BRANCH=mergerequest-$CI_MERGE_REQUEST_IID; else export BRANCH=$CI_COMMIT_BRANCH; fi
    - tools/make-debian -BS
  artifacts:
    paths:
      - pkg/pkgs/*
      - pkg/srcpkgs/*
  rules:
  - *never-wip
  - *never-tag
  - when: always

.pkg-rpm: &pkg-rpm
  stage: pkg
  script:
    - pip3 install apkg
    - apkg build -a bird-$(cat VERSION)*.tar.gz
  artifacts:
    paths:
      - pkg/pkgs/*
      - pkg/srcpkgs/*
  rules:
  - *never-wip
  - *never-tag
  - when: always

.pkg-rpm-wa: &pkg-rpm-wa
  stage: pkg
  script:
    - sed -i "s/runstatedir/with-runtimedir/" distro/pkg/rpm/bird.spec
    # install older version of bs4 that does not use python version >= 3.6
    - pip3 install beautifulsoup4==4.11.2
    - pip3 install apkg
    - apkg build -a bird-$(cat VERSION)*.tar.gz
  artifacts:
    paths:
      - pkg/pkgs/*
      - pkg/srcpkgs/*
  rules:
  - *never-wip
  - *never-tag
  - when: always


{% for dist in distros %}
{%- if dist.arch in ("amd64", "i386") %}
pkg-{{ dist["name"] }}:
  <<: *{{ dist["type"] }}
  needs:
    - job: build-{{ dist["name"] }}
      artifacts: false
    - job: build-release
  image: registry.nic.cz/labs/bird:{{ dist["name"] }}
{%- if 'variables' in dist %}
  variables:
{{ dist["variables"] | to_yaml | indent(4, true) }}
{%- endif %}
{%- endif -%}
{% endfor %}

## Package installability checks

.install-deb: &install-deb
  stage: install
  script:
    # check that bird is _not_ installed now and no user or group bird exists
    - |
      if bird --version >/dev/null 2>&1; then
        echo "Error: BIRD unexpectedly installed"
        exit 1
      fi
      if id -g bird >/dev/null 2>&1; then
        echo "Error: User group 'bird' unexpectedly exist before installation"
        exit 1
      fi
      if id -u bird >/dev/null 2>&1; then
        echo "Error: User 'bird' unexpectedly exist before installation"
        exit 1
      fi
    # install packages
    - find pkg/pkgs/ -type f -name '*.deb' '(' -ls -exec dpkg -i '{}' ';' ')'
    # test that installation is successful
    - ./tools/test-install "$CI_COMMIT_MESSAGE"
  rules:
  - *never-wip
  - *never-tag
  - when: always

.install-rpm: &install-rpm
  stage: install
  script:
    # check that bird is _not_ installed now and no user or group bird exists
    - |
      if bird --version >/dev/null 2>&1; then
        echo "Error: BIRD unexpectedly installed"
        exit 1
      fi
      if id -g bird >/dev/null 2>&1; then
        echo "Error: User group 'bird' exist before installation"
        exit 1
      fi
      if id -u bird >/dev/null 2>&1; then
        echo "Error: User 'bird' exist before installation"
        exit 1
      fi
    # install packages
    - find pkg/pkgs/ -type f -name '*.rpm' '(' -ls -exec rpm -i '{}' ';' ')'
    # test that installation is successful
    - ./tools/test-install "$CI_COMMIT_MESSAGE"
  rules:
  - *never-wip
  - *never-tag
  - when: always

{% for dist in distros %}
{%- if dist.arch in ("amd64", "i386") %}
install-{{ dist["name"] }}:
  <<: *{{ {
    "pkg-rpm": "install-rpm",
    "pkg-rpm-wa": "install-rpm",
    "pkg-deb": "install-deb",
    "pkg-deb-legacy": "install-deb",
  }[dist["type"]] }}
  needs:
    - job: pkg-{{ dist["name"] }}
  image: registry.nic.cz/labs/bird:{{ dist["name"] }}
{%- endif -%}
{% endfor %}

###################################
## DEB Cross-builds by pbuilder  ##
###################################

.crossbuild-deb-image: &crossbuild-deb-image
  stage: image
  script:
    - mkdir -p $PBUILDER_DIR/$IMAGE.cache
    - sudo pbuilder create --architecture $ARCH --distribution $CODE --basetgz $PBUILDER_DIR/$IMAGE.tgz --aptcache $PBUILDER_DIR/$IMAGE.cache --autocleanaptcache --extrapackages "bison flex libncurses-dev m4 quilt xsltproc debhelper docbook-xsl"  --mirror $MIRROR --components "$COMPONENTS"
  tags:
    - crossbuilder
  rules:
    # Never rebuild for WIP commits
  - *never-wip

    # Never rebuild for tags
  - if: '$CI_COMMIT_TAG'
    when: never

    # Never rebuild for new branches
  - if: $CI_COMMIT_BEFORE_SHA == "0000000000000000000000000000000000000000"
    when: never

  - if: $CI_COMMIT_MESSAGE =~ /^PBuilder-init[:] all$/m
    when: always

  - when: never

.crossbuild-deb-pkg: &crossbuild-deb-pkg
  stage: pkg
  script:
    - sudo pbuilder build --architecture $ARCH --distribution $CODE --basetgz $PBUILDER_DIR/$IMAGE.tgz --aptcache $PBUILDER_DIR/$IMAGE.cache --autocleanaptcache --buildresult pkg/pkgs/*/*/ --binary-arch pkg/srcpkgs/*/*/*.dsc --debbuildopts "-j4" --mirror $MIRROR --components "$COMPONENTS"
  tags:
    - crossbuilder
  artifacts:
    paths:
      - pkg/pkgs/*/*/*-cznic*_*.*
  rules:
  - *never-wip
  - *never-tag
  - when: always

{% for dist in distros %}
{%- if dist.arch not in ('amd64', 'i386') %}
crossbuild-image-{{ dist.name }}:
  <<: *crossbuild-deb-image
  variables:
    IMAGE: {{ dist.name }}
    ARCH: {{ dist.arch }}
    CODE: {{ dist.code }}
    MIRROR: {{ dist.mirror }}
    COMPONENTS: {{ dist.components }}
{%- if 'variables' in dist %}
{{ dist["variables"] | to_yaml | indent(4, true) }}
{%- endif %}

crossbuild-pkg-{{ dist.name }}:
  <<: *crossbuild-deb-pkg
  needs:
    - job: crossbuild-image-{{ dist.name }}
      optional: true
    - job: pkg-{{ dist.name[:-(dist.arch | length)] }}amd64
  variables:
    IMAGE: {{ dist.name }}
    ARCH: {{ dist.arch }}
    CODE: {{ dist.code }}
    MIRROR: {{ dist.mirror }}
    COMPONENTS: {{ dist.components }}
{% endif -%}
{% endfor %}



###################################
## Non-linux build tests in QEMU ##
###################################
.build-birdlab-base: &build-birdlab-base
  <<: *build-base
  stage: build
#  script:
#    - export BRANCH=$CI_COMMIT_BRANCH
#    - autoreconf
#    - ./configure $CONFIGURE_OPTIONS
#    - gmake
#    - gmake check

{% for test in birdlab %}
build-birdlab-{{ test['name'] }}:
  <<: *build-birdlab-base
{%- if 'variables' in test %}
  variables:
{{ test['variables'] | to_yaml | indent(4, true) }}{%- endif %}
  tags:
    - birdlab-{{ test['dist'] if 'dist' in test else test['name'] }}
    - amd64
{% endfor %}

#########################
## Partial build tests ##
#########################

.build-only: &build-only
  <<: *build-docker-linux-amd64
  image: registry.nic.cz/labs/bird:{{ partial_build_image["name"] }}
  needs:
    - job: docker-{{ partial_build_image["name"] }}
      optional: true

{% for test in partial_build %}
partial-build-linux-{{ test["protocols"] }}:
  <<: *build-only
  variables:
    CONFIGURE_OPTIONS: --with-protocols={{ test["protocols"] }}
{% endfor %}

################################
## Netlab functionality tests ##
################################

build-netlab:
  stage: build
  variables:
    BDIR: build-netlab
  tags:
    - netlab
    - amd64
  script:
    - if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ]; then export BRANCH=mergerequest-$CI_MERGE_REQUEST_IID; else export BRANCH=$CI_COMMIT_BRANCH; fi
    - autoreconf
    - mkdir $BDIR
    - cd $BDIR
    - ../configure
    - make
  artifacts:
    paths:
      - $BDIR/bird
      - $BDIR/birdc
    expire_in: 2 hours
  rules:
  - *never-wip
  - *never-tag
  - when: always

.netlab-test: &test-base
  stage: test
  needs: [build-netlab]
  tags:
    - netlab
    - amd64
  script:
    - sudo rm -rf netlab-failure
    - DIR=$(pwd)
    - cd $TOOLS_DIR
    - sudo git clean -fx
    - git pull --ff-only
    - "mv $DIR/build-netlab/* netlab/common/"
    - ln -s $STAYRTR_BINARY netlab/common/stayrtr
    - cd netlab
    - sudo ./stop
    - ulimit -f 1048576 # Protect the filesystem from overflowing by log bloat
    - sudo ./runtest -s v2 -m check $TEST_NAME
  after_script:
    - DIR=$(pwd)
    - cd $TOOLS_DIR/netlab
    - sudo ./stop
    - "mkdir $DIR/netlab-failure"
    - git status --porcelain > $DIR/netlab-failure.log
    - for f in $(git status --porcelain | sed -rn 's#^.[^DRT] netlab/##p'); do mkdir -p $DIR/netlab-failure/$(dirname $f); sudo chmod a+rw $f; sudo mv $f $DIR/netlab-failure/$(dirname $f); done
  artifacts:
    when: on_failure
    untracked: true
  rules:
  - *never-wip
  - *never-tag
  - when: always

{% for test in netlab %}
test-{{ test["name"] }}:
  <<: *test-base
  variables:
    TEST_NAME: cf-{{ test["name"] }}
{% endfor %}
