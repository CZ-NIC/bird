/*
 *	This is unit testing configuration file for testing filters
 *
 *	FIXME: add all examples from docs here.
 */

router id 62.168.0.1;

/* We have to setup any protocol */
protocol device { }

attribute bgppath mypath;
attribute lclist mylclist;


/*
 * 	Common definitions and functions
 * 	--------------------------------
 */

define one = 1;
define ten = 10;

function onef(int a) -> int
{
	return 1;
}

function twof(int a) -> int
{
	return 2;
}

function oneg(int a) -> int
{
	return 1;
}

bt_test_same(onef, onef, 1);
bt_test_same(onef, oneg, 1);
bt_test_same(onef, twof, 0);

/*
 *	Testing filter corner cases
 *	---------------------------
 */

function t_nothing() {}
bt_test_suite(t_nothing, "Testing nothing");

function t_metanothing() { t_nothing(); }
bt_test_suite(t_metanothing, "Testing meta nothing");


/*
 * 	Testing boolean expressions
 * 	---------------------------
 */

function t_bool()
{
	bool b = true;
	bt_assert(b);
	bt_assert(!!b);

	bt_assert(format(true)  = "TRUE");
	bt_assert(format(false) = "FALSE");

	if ( b = true ) then
		bt_assert(b);
	else
		bt_assert(false);

	bt_assert(true && true);
	bt_assert(true || false);
	bt_assert(! false && ! false && true);
	bt_assert(1 < 2 && 1 != 3);
	bt_assert(true && true && ! false);
	# bt_assert(true || 1+"a");
	# bt_assert(!(false && 1+"a"));
	bt_assert(!(true && false));
}

bt_test_suite(t_bool, "Testing boolean expressions");



/*
 *	Testing integers
 *	----------------
 */

function aux_t_int(int t; int u)
{
	case t {
		1: {}
		else: {}
	}
}

define four = 4;
define xyzzy = (120+10);
define '1a-a1' = (xyzzy-100);

function t_int()
{
	bt_assert(xyzzy = 130);
	bt_assert('1a-a1' = 30);

	int i = four;
	i = 12*100 + 60/2 + i;
	i = (i + 0);
	bt_assert(i = 1234);

	bt_assert(format(i) = "1234");

	i = 4200000000;
	bt_assert(i = 4200000000);
	bt_assert(i > 4100000000);
	bt_assert(!(i > 4250000000));

	bt_assert(1 = 1);
	bt_assert(!(1 != 1));

	bt_assert(1 != 2);
	bt_assert(1 <= 2);

	bt_assert(1 != "a");
	bt_assert(1 != (0,1));

	bt_assert(!(i = 4));
	bt_assert(1 <= 1);
	bt_assert(!(1234 < 1234));

	case i {
		4200000000: bt_assert(true);
		else: bt_assert(false);
	}

	case four {
		4: bt_assert(true);
		else: bt_assert(false);
	}

	aux_t_int(1, 2);
	aux_t_int(1, 3);
	aux_t_int(2, 3);
	aux_t_int(2, 2);
}

bt_test_suite(t_int, "Testing integers");




/*
 * 	Testing sets of integers
 * 	------------------------
 */

define is1 = [ one, (2+1), (6-one), 8, 11, 15, 17, 19];
define is2 = [(17+2), 17, 15, 11, 8, 5, 3, 2];
define is3 = [5, 17, 2, 11, 8, 15, 3, 19];

function t_int_set()
{
	int set is = [];
	bt_assert(is = []);
	bt_assert(0 !~ is);

	bt_assert(1 ~ [1,2,3]);
	bt_assert(5 ~ [1..20]);
	bt_assert(2 ~ [ 1, 2, 3 ]);
	bt_assert(5 ~ [ 4 .. 7 ]);
	bt_assert(1 !~ [ 2, 3, 4 ]);
	bt_assert(999 !~ [ 666, 333 ]);
	bt_assert(1 !~ []);
	bt_assert(1 !~ is);

	is = [ 2, 3, 4, 7..11 ];
	bt_assert(10 ~ is);
	bt_assert(5 !~ is);

	bt_assert(1 ~ is1);
	bt_assert(3 ~ is1);
	bt_assert(5 ~ is1);
	bt_assert((one+2) ~ is1);
	bt_assert(2 ~ is2);
	bt_assert(2 ~ is3);
	bt_assert(4 !~ is1);
	bt_assert(4 !~ is2);
	bt_assert(4 !~ is3);
	bt_assert(10 !~ is1);
	bt_assert(10 !~ is2);
	bt_assert(10 !~ is3);
	bt_assert(15 ~ is1);
	bt_assert(15 ~ is2);
	bt_assert(15 ~ is3);
	bt_assert(18 !~ is1);
	bt_assert(18 !~ is2);
	bt_assert(18 !~ is3);
	bt_assert(19 ~ is1);
	bt_assert(19 ~ is2);
	bt_assert(19 ~ is3);
	bt_assert(20 !~ is1);
	bt_assert(20 !~ is2);
	bt_assert(20 !~ is3);

	bt_assert([1,2] != [1,3]);
	bt_assert([1,4..10,20] = [1,4..10,20]);

	bt_assert(format([ 1, 2, 1, 1, 1, 3, 4, 1, 1, 1, 5 ]) = "[1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5]");
	bt_assert(format([]) = "[]");
}

bt_test_suite(t_int_set, "Testing sets of integers");




/*
 * 	Testing string matching
 * 	-----------------------
 */

function t_string()
{
	string st = "Hello";
	bt_assert(format(st) = "Hello");
	bt_assert(st ~ "Hell*");
	bt_assert(st ~ "?ello");
	bt_assert(st ~ "Hello");
	bt_assert(st ~ "Hell?");
	bt_assert(st !~ "ell*");
}

bt_test_suite(t_string, "Testing string matching");




/*
 * 	Testing bytestings
 * 	------------------
 */

function t_bytestring()
{
	bytestring bs1 = hex:;
	bytestring bs2 = hex:0112233445566778899aabbccddeeff0;

	bt_assert(format(bs1) = "");
	bt_assert(format(bs2) = "01:12:23:34:45:56:67:78:89:9a:ab:bc:cd:de:ef:f0");
	bt_assert(hex:01:12:23:34:45:56:67:78:89:9a:ab:bc:cd:de:ef:f0 = bs2);
	bt_assert(01:12:23:34:45:56:67:78:89:9a:ab:bc:cd:de:ef:f0 = bs2);
	bt_assert(0112233445566778899aabbccddeeff0 = bs2);
	bt_assert(hex:01234567 = hex:01:23:45:67);
	bt_assert(hex:0123456789abcdef != bs2);
	bt_assert(hex:0123456789abcdef != hex:0123);
	bt_assert(format(hex:0123456789abcdef) = "01:23:45:67:89:ab:cd:ef");
	bt_assert(from_hex(" ") = bs1);
	bt_assert(from_hex("01:12:23:34:45:56:67:78:89:9a:ab:bc:cd:de:ef:f0") = bs2);
	bt_assert(from_hex(format(bs2)) = bs2);
	bt_assert(from_hex(" 0112:23-34455667 78-89 - 9a-ab bc:cd : de:eff0 ") = bs2);
}

bt_test_suite(t_bytestring, "Testing bytestrings");




/*
 * 	Testing pairs
 * 	-------------
 */

function 'mkpair-a'(int a) -> pair
{
	return (1, a);
}

function t_pair()
{
	pair pp = (1, 2);
	bt_assert(format(pp) = "(1,2)");
	bt_assert((1,2) = pp);
	bt_assert((1,1+1) = pp);
	bt_assert('mkpair-a'(2) = pp);
	bt_assert((1,2) = (1,1+1));
	bt_assert(((1,2) < (2,2)));
	bt_assert(!((1,1) > (1,1)));
}

bt_test_suite(t_pair, "Testing pairs");




/*
 * 	Testing sets of pairs
 * 	---------------------
 */

function t_pair_set()
{
	pair pp = (1, 2);
	pair set ps = [];
	bt_assert(pp !~ ps);

	ps = [(1,(one+one)), (3,4)..(4,8), (5,*), (6,3..6)];
	bt_assert(format(ps) = "[(1,2), (3,4)..(4,8), (5,0)..(5,65535), (6,3)..(6,6)]");
	bt_assert(pp ~ ps);
	bt_assert((3,5) ~ ps);
	bt_assert((4,1) ~ ps);
	bt_assert((5,4) ~ ps);
	bt_assert((5,65535) ~ ps);
	bt_assert((6,4) ~ ps);
	bt_assert((3, 10000) ~ ps);
	bt_assert((3,3) !~ ps);
	bt_assert((4,9) !~ ps);
	bt_assert((4,65535) !~ ps);
	bt_assert((6,2) !~ ps);
	bt_assert((6,6+one) !~ ps);
	bt_assert(((one+6),2) !~ ps);
	bt_assert((1,1) !~ ps);
	bt_assert(pp !~ []);

	ps = [(20..150, 200..300), (50100..50200, 1000..50000), (*, 5+5)];
	bt_assert((100,200) ~ ps);
	bt_assert((150,300) ~ ps);
	bt_assert((50180,1200) ~ ps);
	bt_assert((50110,49000) ~ ps);
	bt_assert((0,10) ~ ps);
	bt_assert((64000,10) ~ ps);
	bt_assert((20,199) !~ ps);
	bt_assert((151,250) !~ ps);
	bt_assert((50050,2000) !~ ps);
	bt_assert((50150,50050) !~ ps);
	bt_assert((10,9) !~ ps);
	bt_assert((65535,11) !~ ps);
}

bt_test_suite(t_pair_set, "Testing sets of pairs");




/*
 * 	Testing quads
 * 	-------------
 */

function t_quad()
quad qq;
{
	qq = 1.2.3.4;
	bt_assert(format(qq) = "1.2.3.4");
	bt_assert(qq = 1.2.3.4);
	bt_assert(qq != 4.3.2.1);
}

bt_test_suite(t_quad, "Testing quads");




/*
 * 	Testing sets of quads
 * 	---------------------
 */

function t_quad_set()
quad qq;
{
	qq = 1.2.3.4;
	bt_assert(qq ~ [1.2.3.4, 5.6.7.8]);
	bt_assert(qq !~ [1.2.1.1, 1.2.3.5]);
	bt_assert(qq !~ []);
}

bt_test_suite(t_quad_set, "Testing sets of quads");




/*
 * 	Testing ip address
 * 	------------------
 */

define onetwo = 1.2.3.4;

function t_ip()
ip p;
{
	p = 127.1.2.3;
	bt_assert(p.is_v4);
	bt_assert(p.mask(8) = 127.0.0.0);
	bt_assert(1.2.3.4 = 1.2.3.4);
	bt_assert(1.2.3.4 = onetwo);
	bt_assert(format(p) = "127.1.2.3");

	p = ::fffe:6:c0c:936d:88c7:35d3;
	bt_assert(!p.is_v4);
	bt_assert(format(p) = "::fffe:6:c0c:936d:88c7:35d3");

	p = 1234:5678::;
	bt_assert(!p.is_v4);
	bt_assert(p.mask(24) = 1234:5600::);

	p = 1:2:3:4:5:6:7:8;
	bt_assert(!p.is_v4);
	bt_assert(format(p) = "1:2:3:4:5:6:7:8");
	bt_assert(p.mask(64) = 1:2:3:4::);

	p = 10:20:30:40:50:60:70:80;
	bt_assert(!p.is_v4);
	bt_assert(format(p) = "10:20:30:40:50:60:70:80");
	bt_assert(p.mask(64) = 10:20:30:40::);

	p = 1090:20a0:30b0:40c0:50d0:60e0:70f0:8000;
	bt_assert(!p.is_v4);
	bt_assert(format(p) = "1090:20a0:30b0:40c0:50d0:60e0:70f0:8000");
	bt_assert(p.mask(64) = 1090:20a0:30b0:40c0::);

	p = ::fffe:6:c0c:936d:88c7:35d3;
	bt_assert(!p.is_v4);
	bt_assert(format(p) = "::fffe:6:c0c:936d:88c7:35d3");
	bt_assert(p.mask(64) = 0:0:fffe:6::);
}

bt_test_suite(t_ip, "Testing ip address");




/*
 * 	Testing sets of ip address
 * 	--------------------------
 */

define ip1222 = 1.2.2.2;

function t_ip_set()
ip set ips;
{
	ips = [ 1.1.1.0 .. 1.1.1.255, ip1222];
	bt_assert(format(ips) = "[1.1.1.0..1.1.1.255, 1.2.2.2]");
	bt_assert(1.1.1.0 ~ ips);
	bt_assert(1.1.1.100 ~ ips);
	bt_assert(1.2.2.2 ~ ips);
	bt_assert(1.1.0.255 !~ ips);
	bt_assert(1.1.2.0  !~ ips);
	bt_assert(1.2.2.3 !~ ips);
	bt_assert(192.168.1.1 !~ ips);

	bt_assert(1.2.3.4 !~ [ 1.2.3.3, 1.2.3.5 ]);
	bt_assert(1.2.3.4 ~ [ 1.2.3.3..1.2.3.5 ]);
	bt_assert(1.2.3.4 !~ []);
}

bt_test_suite(t_ip_set, "Testing sets of ip address");




/*
 *	Testing enums
 *	-------------
 */

function t_enum()
{
	bt_assert(format(RTS_STATIC) = "(enum 30)1");
	bt_assert(format(NET_IP4) = "(enum 36)1");
	bt_assert(format(NET_VPN6) = "(enum 36)4");

	bt_assert(RTS_STATIC ~ [RTS_STATIC, RTS_DEVICE]);
	bt_assert(RTS_BGP !~ [RTS_STATIC, RTS_DEVICE]);
}

bt_test_suite(t_enum, "Testing enums");




/*
 * 	Testing prefixes
 * 	----------------
 */

define netdoc = 2001:db8::/32;

function t_prefix()
prefix px;
{
	px = 1.2.0.0/18;
	bt_assert(format(px) = "1.2.0.0/18");
	bt_assert(192.168.0.0/16 ~ 192.168.0.0/16);
	bt_assert(192.168.0.0/17 ~ 192.168.0.0/16);
	bt_assert(192.168.254.0/24 ~ 192.168.0.0/16);
	bt_assert(netdoc ~ 2001::/16);
	bt_assert(192.168.0.0/15 !~ 192.168.0.0/16);
	bt_assert(192.160.0.0/17 !~ 192.168.0.0/16);
	bt_assert(px !~ netdoc);

	bt_assert(1.2.3.4 ~ 1.0.0.0/8);
	bt_assert(1.0.0.0/8 ~ 1.0.0.0/8);
}

bt_test_suite(t_prefix, "Testing prefixes");




/*
 *	Testing prefix sets
 *	-------------------
 */

define net10 = 10.0.0.0/8;
define pxs2 = [ 10.0.0.0/16{8,12}, 20.0.0.0/16{24,28} ];

function test_pxset(prefix set pxs)
{
	bt_assert(net10  ~ pxs);
	bt_assert(10.0.0.0/10  ~ pxs);
	bt_assert(10.0.0.0/12 ~ pxs);
	bt_assert(20.0.0.0/24 ~ pxs);
	bt_assert(20.0.40.0/24 ~ pxs);
	bt_assert(20.0.0.0/26 ~ pxs);
	bt_assert(20.0.100.0/26 ~ pxs);
	bt_assert(20.0.0.0/28 ~ pxs);
	bt_assert(20.0.255.0/28 ~ pxs);

	bt_assert(10.0.0.0/7 !~ pxs);
	bt_assert(10.0.0.0/13 !~ pxs);
	bt_assert(10.0.0.0/16 !~ pxs);
	bt_assert(20.0.0.0/16 !~ pxs);
	bt_assert(20.0.0.0/23 !~ pxs);
	bt_assert(20.0.0.0/29 !~ pxs);
	bt_assert(11.0.0.0/10 !~ pxs);
	bt_assert(20.1.0.0/26 !~ pxs);

	bt_assert(1.0.0.0/8 ~ [ 1.0.0.0/8+ ]);
	bt_assert(1.0.0.0/9 !~ [ 1.0.0.0/8- ]);
	bt_assert(1.2.0.0/17 !~ [ 1.0.0.0/8{ 15 , 16 } ]);
	bt_assert(net10 !~ []);

	bt_assert([ 10.0.0.0/8{ 15 , 17 } ] = [ 10.0.0.0/8{ 15 , 17 } ]);
}

function test_empty_pxset(prefix set pxs)
int set s0;
prefix set s1;
{
	s0 = [];
	s1 = [];
	bt_assert(pxs != s0);
	bt_assert(pxs = s1);
	bt_assert(pxs = []);
}

function t_prefix_set()
prefix set pxs;
{
	pxs = [];
	bt_assert(format(pxs) = "[]");
	bt_assert(pxs = []);
	bt_assert(1.2.0.0/16 !~ []);
	bt_assert(1.2.0.0/16 !~ pxs);

	test_empty_pxset([]);
	test_empty_pxset(pxs);

	pxs = [ 1.2.0.0/16, 1.4.0.0/16+, 44.66.88.64/30{24,28}, 12.34.56.0/24{8,16} ];
	bt_assert(format(pxs) = "[1.2.0.0/16{0.1.0.0}, 1.4.0.0/16{0.1.255.255}, 12.34.0.0/16{1.255.0.0}, 44.66.88.64/28{0.0.1.240}]");

	bt_assert(1.2.0.0/16 ~ pxs);
	bt_assert(1.4.0.0/16 ~ pxs);
	bt_assert(1.4.0.0/18 ~ pxs);
	bt_assert(1.4.0.0/32 ~ pxs);
	bt_assert(1.1.0.0/16 !~ pxs);
	bt_assert(1.3.0.0/16 !~ pxs);
	bt_assert(1.2.0.0/15 !~ pxs);
	bt_assert(1.2.0.0/17 !~ pxs);
	bt_assert(1.2.0.0/32 !~ pxs);
	bt_assert(1.4.0.0/15 !~ pxs);

	test_pxset(pxs2);
	test_pxset([ 10.0.0.0/16{8,12}, 20.0.0.0/16{24,28} ]);

	bt_assert(1.2.0.0/16 ~ [ 1.0.0.0/8{ 15 , 17 } ]);
	bt_assert([ 10.0.0.0/8{ 15 , 17 } ] != [ 11.0.0.0/8{ 15 , 17 } ]);

	/* Formatting of prefix sets, some cases are a bit strange */
	bt_assert(format([ 0.0.0.0/0 ]) = "[0.0.0.0/0]");
	bt_assert(format([ 10.10.0.0/32 ]) = "[10.10.0.0/32{0.0.0.1}]");
	bt_assert(format([ 10.10.0.0/17 ]) = "[10.10.0.0/17{0.0.128.0}]");
	# bt_assert(format([ 10.10.0.0/17{17,19} ]) = "[10.10.0.0/17{0.0.224.0}]"); # 224 = 128+64+32
	bt_assert(format([ 10.10.128.0/17{18,19} ]) = "[10.10.128.0/18{0.0.96.0}, 10.10.192.0/18{0.0.96.0}]"); # 96 = 64+32
	# bt_assert(format([ 10.10.64.0/18- ]) = "[0.0.0.0/0, 0.0.0.0/1{128.0.0.0}, 0.0.0.0/2{64.0.0.0}, 0.0.0.0/3{32.0.0.0}, 10.10.0.0/16{255.255.0.0}, 10.10.0.0/17{0.0.128.0}, 10.10.64.0/18{0.0.64.0}]");
	# bt_assert(format([ 10.10.64.0/18+ ]) = "[10.10.64.0/18{0.0.96.0}, 10.10.64.0/20{0.0.31.255}, 10.10.80.0/20{0.0.31.255}, 10.10.96.0/20{0.0.31.255}, 10.10.112.0/20{0.0.31.255}]");

	bt_assert(format([ 10.10.160.0/19 ]) = "[10.10.160.0/19{0.0.32.0}]");
	bt_assert(format([ 10.10.160.0/19{19,22} ]) = "[10.10.160.0/19{0.0.32.0}, 10.10.160.0/20{0.0.28.0}, 10.10.176.0/20{0.0.28.0}]"); # 28 = 16+8+4
	bt_assert(format([ 10.10.160.0/19+ ]) = "[10.10.160.0/19{0.0.32.0}, 10.10.160.0/20{0.0.31.255}, 10.10.176.0/20{0.0.31.255}]");

	bt_assert(format([ ::/0 ]) = "[::/0]");
	bt_assert(format([ 11:22:33:44:55:66:77:88/128 ]) = "[11:22:33:44:55:66:77:88/128{::1}]");
	bt_assert(format([ 11:22:33:44::/64 ]) = "[11:22:33:44::/64{0:0:0:1::}]");
	bt_assert(format([ 11:22:33:44::/64+ ]) = "[11:22:33:44::/64{::1:ffff:ffff:ffff:ffff}]");

	bt_assert(format([ 11:22:33:44::/65 ]) = "[11:22:33:44::/65{::8000:0:0:0}]");
	# bt_assert(format([ 11:22:33:44::/65{65,67} ]) = "[11:22:33:44::/65{::e000:0:0:0}]"); # e = 8+4+2
	bt_assert(format([ 11:22:33:44:8000::/65{66,67} ]) = "[11:22:33:44:8000::/66{::6000:0:0:0}, 11:22:33:44:c000::/66{::6000:0:0:0}]"); # 6 = 4+2
	# bt_assert(format([ 11:22:33:44:4000::/66- ]) = "[::/0, ::/1{8000::}, ::/2{4000::}, ::/3{2000::}, 11:22:33:44::/64{ffff:ffff:ffff:ffff::}, 11:22:33:44::/65{::8000:0:0:0}, 11:22:33:44:4000::/66{::4000:0:0:0}]");
	# bt_assert(format([ 11:22:33:44:4000::/66+ ]) = "[11:22:33:44:4000::/66{::6000:0:0:0}, 11:22:33:44:4000::/68{::1fff:ffff:ffff:ffff}, 11:22:33:44:5000::/68{::1fff:ffff:ffff:ffff}, 11:22:33:44:6000::/68{::1fff:ffff:ffff:ffff}, 11:22:33:44:7000::/68{::1fff:ffff:ffff:ffff}]");
	bt_assert(format([ 11:22:33:44:c000::/67 ]) = "[11:22:33:44:c000::/67{::2000:0:0:0}]");
	bt_assert(format([ 11:22:33:44:c000::/67{67,71} ]) = "[11:22:33:44:c000::/67{::2000:0:0:0}, 11:22:33:44:c000::/68{::1e00:0:0:0}, 11:22:33:44:d000::/68{::1e00:0:0:0}]");
	bt_assert(format([ 11:22:33:44:c000::/67+ ]) = "[11:22:33:44:c000::/67{::2000:0:0:0}, 11:22:33:44:c000::/68{::1fff:ffff:ffff:ffff}, 11:22:33:44:d000::/68{::1fff:ffff:ffff:ffff}]");
}

bt_test_suite(t_prefix_set, "Testing prefix sets");




/*
 * 	Testing Prefix IPv6
 * 	-------------------
 */

function t_prefix6()
{
	prefix px;
	px = 1020::/18;
	bt_assert(format(px) = "1020::/18");
	bt_assert(1020:3040:5060:: ~ 1020:3040:5000::/40);
	bt_assert(1020:3040::/32 ~ 1020:3040::/32);
	bt_assert(1020:3040::/33 ~ 1020:3040::/32);
	bt_assert(1020:3040:5060::/48 ~ 1020:3040::/32);
	bt_assert(1020:3040::/31 !~ 1020:3040::/32);
	bt_assert(1020:3041::/33 !~ 1020:3040::/32);
}

bt_test_suite(t_prefix6, "Testing prefix IPv6");




/*
 *	Testing prefix IPv6 sets
 *	------------------------
 */

function t_prefix6_set()
prefix set pxs;
{
	pxs = [];
	bt_assert(format(pxs) = "[]");
	bt_assert(pxs = []);
	bt_assert(12::34/128 !~ []);
	bt_assert(12::34/128 !~ pxs);

	bt_assert(1180::/16 ~ [ 1100::/8{15, 17} ]);
	bt_assert(12::34 = 12::34);
	bt_assert(12::34 ~ [ 12::33..12::35 ]);
	bt_assert(1020::34 ~ 1000::/8);
	bt_assert(1000::/8 ~ 1000::/8);
	bt_assert(1000::/8 ~ [ 1000::/8+ ]);
	bt_assert(12::34 !~ [ 12::33, 12::35 ]);
	bt_assert(1000::/9 !~ [ 1000::/8- ]);
	bt_assert(1000::/17 !~ [ 1000::/8{15, 16} ]);

	pxs = [ 1102::/16, 1104::/16+];
	bt_assert(1102::/16  ~ pxs);
	bt_assert(1104::/16  ~ pxs);
	bt_assert(1104::/18  ~ pxs);
	bt_assert(1104::/32  ~ pxs);
	bt_assert(1101::/16 !~ pxs);
	bt_assert(1103::/16 !~ pxs);
	bt_assert(1102::/15 !~ pxs);
	bt_assert(1102::/17 !~ pxs);
	bt_assert(1102::/32 !~ pxs);
	bt_assert(1104::/15 !~ pxs);

	pxs = ([ 1000::/16{8,12}, 2000::/16{24,28} ]);
	bt_assert(format(pxs) = "[1000::/12{1f0::}, 2000::/16{0:1f0::}]");
	bt_assert(1000::/8  ~ pxs);
	bt_assert(1000::/10 ~ pxs);
	bt_assert(1000::/12 ~ pxs);
	bt_assert(2000::/24 ~ pxs);
	bt_assert(2000:4000::/24 ~ pxs);
	bt_assert(2000::/26 ~ pxs);
	bt_assert(2000:8000::/26 ~ pxs);
	bt_assert(2000::/28 ~ pxs);
	bt_assert(2000:FFF0::/28 ~ pxs);
	bt_assert(1000::/7  !~ pxs);
	bt_assert(1000::/13 !~ pxs);
	bt_assert(1000::/16 !~ pxs);
	bt_assert(2000::/16 !~ pxs);
	bt_assert(2000::/23 !~ pxs);
	bt_assert(2000::/29 !~ pxs);
	bt_assert(1100::/10 !~ pxs);
	bt_assert(2010::/26 !~ pxs);

	pxs = [ 52E0::/13{13,128} ];
	bt_assert(52E7:BE81:379B:E6FD:541F:B0D0::/93 ~ pxs);

	pxs = [ 41D8:8718::/30{0,30}, 413A:99A8:6C00::/38{38,128} ];
	bt_assert(4180::/9 ~ pxs);
}

bt_test_suite(t_prefix6_set, "Testing prefix IPv6 sets");




function t_flowspec()
prefix p;
{
	p = flow4 { dst 10.0.0.0/8; };
	bt_assert(p !~ [ 10.0.0.0/8 ] );

	bt_assert(format(flow4 { dst 10.0.0.0/8; proto = 23; }) = "flow4 { dst 10.0.0.0/8; proto 23; }");
	bt_assert(format(flow6 { dst ::1/128; src ::2/127; }) = "flow6 { dst ::1/128; src ::2/127; }");
	bt_assert(format(flow6 { next header false 42; }) = "flow6 { next header false 42; }");
	bt_assert(format(flow6 { port 80; }) = "flow6 { port 80; }");
	bt_assert(format(flow6 { dport > 24 && < 30 || 40..50,60..70,80 && >= 90; }) = "flow6 { dport > 24 && < 30 || 40..50,60..70,80 && >= 90; }");
	bt_assert(format(flow6 { sport 0..0x400; }) = "flow6 { sport 0..1024; }");
	bt_assert(format(flow6 { icmp type 80; }) = "flow6 { icmp type 80; }");
	bt_assert(format(flow6 { icmp code 90; }) = "flow6 { icmp code 90; }");
	bt_assert(format(flow6 { tcp flags 0x03/0x0f; }) = "flow6 { tcp flags 0x3/0x3 && 0x0/0xc; }");
	bt_assert(format(flow6 { length 0..65535; }) = "flow6 { length 0..65535; }");
	bt_assert(format(flow6 { dscp = 63; }) = "flow6 { dscp 63; }");
	bt_assert(format(flow6 { fragment is_fragment || !first_fragment; }) = "flow6 { fragment is_fragment || !first_fragment; }");
	bt_assert(format(flow6 { label 1000..2000; }) = "flow6 { label 1000..2000; }");
	bt_assert(format(flow6 { }) = "flow6 { }");
}

bt_test_suite(t_flowspec, "Testing flowspec routes");




/*
 * 	Testing Paths
 * 	-------------
 */

function mkpath(int a; int b) -> bgpmask
{
	return [= a b 3 2 1 =];
}

define set35 = [3 .. 5];

function t_path_old()
bgpmask pm1;
bgppath p2;
int set set12;
{
	pm1 = [= 4 3 2 1 =];
	set12 = [1, 2];

	bt_assert(format(pm1) = "[= 4 3 2 1 =]");

	bt_assert(+empty+ = +empty+);
	bt_assert(10 !~ +empty+);

	p2 = prepend( + empty +, 1 );
	p2 = prepend( p2, 2 );
	p2 = prepend( p2, 3 );
	p2 = prepend( p2, 4 );

	bt_assert(format(p2) = "(path 4 3 2 1)");
	bt_assert(p2.len = 4);
	bt_assert(p2 ~ pm1);
	bt_assert(3 ~ p2);
	bt_assert(p2 ~ [2, 10..20]);
	bt_assert(p2 ~ [4, 10..20]);
	bt_assert(p2 !~ []);

	p2 = prepend(p2, 5);
	bt_assert(p2 !~ pm1);
	bt_assert(10 !~ p2);
	bt_assert(p2 !~ [8, ten..(2*ten)]);
	bt_assert(p2 ~ [= * 4 3 * 1 =]);
	bt_assert(p2 ~ [= (3+2) (2*2) 3 2 1 =]);
	bt_assert(p2 ~ [= 5 [2, 4, 6] 3 [1..2] 1 =]);
	bt_assert(p2 ~ [= 5 set35 3 set12 set12 =]);
	bt_assert(p2 ~ mkpath(5, 4));
	bt_assert(p2 ~ [= * [3] * =]);
	bt_assert(p2 !~ [= * [] * =]);

	bt_assert(p2.len = 5);
	bt_assert(p2.first = 5);
	bt_assert(p2.last = 1);

	bt_assert(p2.len = 5);
	bt_assert(delete(p2, 3) = prepend(prepend(prepend(prepend(+empty+, 1), 2), 4), 5));
	bt_assert(filter(p2, [1..3]) = prepend(prepend(prepend(+empty+, 1), 2), 3));
	bt_assert(delete(p2, []) = p2);
	bt_assert(filter(p2, []) = +empty+);
	bt_assert(delete(prepend(prepend(+empty+, 0), 1), []) = prepend(prepend(+empty+, 0), 1));
	bt_assert(filter(prepend(prepend(+empty+, 0), 1), []) = +empty+);

	p2 = prepend( + empty +, 5 );
	p2 = prepend( p2, 4 );
	p2 = prepend( p2, 3 );
	p2 = prepend( p2, 3 );
	p2 = prepend( p2, 2 );
	p2 = prepend( p2, 1 );

	bt_assert(p2 !~ [= 1 2 3 4 5 =]);
	bt_assert(p2 ~ [= 1 2 * 4 5 =]);
	bt_assert(p2 ~ [= 1 2 * 3 4 5 =]);
	bt_assert(p2 ~ [= 1 2 3+ 4 5 =]);
	bt_assert(p2 ~ [= 1 2 3+ 4+ 5 =]);
	bt_assert(p2 !~ [= 1 2 3+ 5+ 4 5 =]);
	bt_assert(p2 !~ [= 1 2 3 3 5+ 4 5 =]);
	bt_assert(delete(p2, 3) = prepend(prepend(prepend(prepend(+empty+, 5), 4), 2), 1));
	bt_assert(delete(p2, [4..5]) = prepend(prepend(prepend(prepend(+empty+, 3), 3), 2), 1));

	bt_assert(format([= 1 2+ 3 =]) = "[= 1 2 + 3 =]");

	# iteration over path
	int x = 0;
	int y = 0;
	for int i in p2 do {
	    x = x + i;
	    y = y + x;
	}
	bt_assert(x = 18 && y = 50);
}

bt_test_suite(t_path_old, "Testing paths (old syntax)");


function t_path_new()
{
	bgpmask pm1 = [= 4 3 2 1 =];
	int set set12 = [1, 2];

	bt_assert(format(pm1) = "[= 4 3 2 1 =]");

	bt_assert(+empty+ = +empty+);
	bt_assert(10 !~ +empty+);

	bgppath p2;
	bt_assert(p2 = +empty+);
	p2.prepend(1);
	p2.prepend(2);
	p2.prepend(3);
	p2.prepend(4);

	bt_assert(p2.empty = +empty+);

	bt_assert(format(p2) = "(path 4 3 2 1)");
	bt_assert(p2.len = 4);
	bt_assert(p2 ~ pm1);
	bt_assert(3 ~ p2);
	bt_assert(p2 ~ [2, 10..20]);
	bt_assert(p2 ~ [4, 10..20]);
	bt_assert(p2 !~ []);

	p2.prepend(5);
	bt_assert(p2 !~ pm1);
	bt_assert(10 !~ p2);
	bt_assert(p2 !~ [8, ten..(2*ten)]);
	bt_assert(p2 ~ [= * 4 3 * 1 =]);
	bt_assert(p2 ~ [= (3+2) (2*2) 3 2 1 =]);
	bt_assert(p2 ~ [= 5 [2, 4, 6] 3 [1..2] 1 =]);
	bt_assert(p2 ~ [= 5 set35 3 set12 set12 =]);
	bt_assert(p2 ~ mkpath(5, 4));
	bt_assert(p2 ~ [= * [3] * =]);
	bt_assert(p2 !~ [= * [] * =]);

	bt_assert(p2.len = 5);
	bt_assert(p2.first = 5);
	bt_assert(p2.last = 1);

	bt_assert(p2.len = 5);
	bt_assert(p2.delete(3) = +empty+.prepend(1).prepend(2).prepend(4).prepend(5));
	bt_assert(p2.filter([1..3]) = +empty+.prepend(1).prepend(2).prepend(3));
	bt_assert(p2.delete([]) = p2);
	bt_assert(p2.filter([]) = +empty+);
	bt_assert(+empty+.prepend(0).prepend(1).delete([]) = +empty+.prepend(0).prepend(1));
	bt_assert(+empty+.prepend(0).prepend(1).filter([]) = +empty+);

	p2 = +empty+;
	p2.prepend(5);
	p2.prepend(4);
	p2.prepend(3);
	p2.prepend(3);
	p2.prepend(2);
	p2.prepend(1);

	bt_assert(p2 !~ [= 1 2 3 4 5 =]);
	bt_assert(p2 ~ [= 1 2 * 4 5 =]);
	bt_assert(p2 ~ [= 1 2 * 3 4 5 =]);
	bt_assert(p2 ~ [= 1 2 3+ 4 5 =]);
	bt_assert(p2 ~ [= 1 2 3+ 4+ 5 =]);
	bt_assert(p2 !~ [= 1 2 3+ 5+ 4 5 =]);
	bt_assert(p2 !~ [= 1 2 3 3 5+ 4 5 =]);
	bt_assert(p2.delete(3) = +empty+.prepend(5).prepend(4).prepend(2).prepend(1));
	bt_assert(p2.delete([4..5]) = +empty+.prepend(3).prepend(3).prepend(2).prepend(1));

	bt_assert(format([= 1 2+ 3 =]) = "[= 1 2 + 3 =]");

	# iteration over path
	int x = 0;
	int y = 0;
	for int i in p2 do {
	    x = x + i;
	    y = y + x;
	}
	bt_assert(x = 18 && y = 50);
}

bt_test_suite(t_path_new, "Testing paths (new syntax)");




/*
 * 	Testing Community List
 *	----------------------
 */

define p23 = (2, 3);

function t_clist_old()
clist l;
clist l2;
clist r;
{
	bt_assert((10, 20).asn = 10);
	bt_assert((10, 20).data = 20);
	bt_assert(p23.asn = 2);
	bt_assert(p23.data = 3);

	l = - empty -;
	bt_assert(l !~ [(*,*)]);
	bt_assert((l ~ [(*,*)]) != (l !~ [(*,*)]));

	bt_assert(-empty- = -empty-);

	l = add( l, (one,2) );
	bt_assert(l ~ [(*,*)]);
	l = add( l, (2,one+2) );
	bt_assert(format(l) = "(clist (1,2) (2,3))");

	bt_assert((2,3) ~ l);
	bt_assert(l ~ [(1,*)]);
	bt_assert(l ~ [p23]);
	bt_assert(l ~ [(2,2..3)]);
	bt_assert(l ~ [(1,1..2)]);
	bt_assert(l ~ [(1,1)..(1,2)]);
	bt_assert(l !~ []);

	l = add(l, (2,5));
	l = add(l, (5,one));
	l = add(l, (6,one));
	l = add(l, (one,one));
	l = delete(l, [(5,1),(6,one),(one,1)]);
	l = delete(l, [(5,one),(6,one)]);
	l = filter(l, [(1,*)]);
	bt_assert(l = add(-empty-, (1,2)));

	bt_assert((2,3) !~ l);
	bt_assert(l !~ [(2,*)]);
	bt_assert(l !~ [(one,3..6)]);
	bt_assert(l ~ [(*,*)]);

	l = add(l, (3,one));
	l = add(l, (one+one+one,one+one));
	l = add(l, (3,3));
	l = add(l, (3,4));
	l = add(l, (3,5));
	l2 = filter(l, [(3,*)]);
	l = delete(l, [(3,2..4)]);
	bt_assert(l = add(add(add(-empty-, (1,2)), (3,1)), (3,5)));
	bt_assert(l.len = 3);

	l = add(l, (3,2));
	l = add(l, (4,5));
	bt_assert(l = add(add(add(add(add(-empty-, (1,2)), (3,1)), (3,5)), (3,2)), (4,5)));

	bt_assert(l.len = 5);
	bt_assert(l ~ [(*,2)]);
	bt_assert(l ~ [(*,5)]);
	bt_assert(l ~ [(*, one)]);
	bt_assert(l !~ [(*,3)]);
	bt_assert(l !~ [(*,(one+6))]);
	bt_assert(l !~ [(*, (one+one+one))]);

	bt_assert(delete(l, []) = l);
	bt_assert(filter(l, []) = -empty-);

	l = delete(l, [(*,(one+onef(3)))]);
	l = delete(l, [(*,(4+one))]);
	bt_assert(l = add(-empty-, (3,1)));

	l = delete(l, [(*,(onef(5)))]);
	bt_assert(l = -empty-);

	l2 = add(l2, (3,6));
	l = filter(l2, [(3,1..4)]);
	l2 = filter(l2, [(3,3..6)]);

	quad q = 2.0.1.0;
	clist ql = add(add(add(-empty-, 1.0.0.1), q), 3.1.0.0);
	bt_assert(delete(ql, 1.0.0.1) = add(add(-empty-, 2.0.1.0), 3.1.0.0));
	bt_assert(delete(ql, [2.0.0.0 .. 4.0.0.0]) = add(-empty-, 1.0.0.1));
	bt_assert(filter(ql, [3.0.0.0 .. 4.0.0.0]) = add(-empty-, 3.1.0.0));

	#  clist A (10,20,30)
	bt_assert(l = add(add(add(add(-empty-, (3,1)), (3,2)), (3,3)), (3,4)));
	bt_assert(format(l) = "(clist (3,1) (3,2) (3,3) (3,4))");

	#  clist B (30,40,50)
	bt_assert(l2 = add(add(add(add(-empty-, (3,3)), (3,4)), (3,5)), (3,6)));
	bt_assert(format(l2) = "(clist (3,3) (3,4) (3,5) (3,6))");

	#  clist A union B
	r = add(l, l2);
	bt_assert(r = add(add(add(add(add(add(-empty-, (3,1)), (3,2)), (3,3)), (3,4)), (3,5)), (3,6)));
	bt_assert(format(r) = "(clist (3,1) (3,2) (3,3) (3,4) (3,5) (3,6))");

	#  clist A isect B
	r = filter(l, l2);
	bt_assert(r = add(add(-empty-, (3,3)), (3,4)));
	bt_assert(format(r) = "(clist (3,3) (3,4))");

	#  clist A \ B
	r = delete(l, l2);
	bt_assert(r = add(add(-empty-, (3,1)), (3,2)));
	bt_assert(format(r) = "(clist (3,1) (3,2))");

	#  clist in c set
	r = filter(l, [(3,1), (*,2)]);
	bt_assert(r = add(add(-empty-, (3,1)), (3,2)));
	bt_assert(format(r) = "(clist (3,1) (3,2))");

	#  minimim & maximum element
	r = add(add(add(add(add(-empty-, (2,1)), (1,3)), (2,2)), (3,1)), (2,3));
	bt_assert(format(r) = "(clist (2,1) (1,3) (2,2) (3,1) (2,3))");
	bt_assert(r.min = (1,3));
	bt_assert(r.max = (3,1));

	# iteration over clist
	int x = 0;
	for pair c in r do
	    x = x + c.asn * c.asn * c.data;
	bt_assert(x = 36);
}

bt_test_suite(t_clist_old, "Testing lists of communities (old syntax)");

function t_clist_new()
{
	bt_assert((10, 20).asn = 10);
	bt_assert((10, 20).data = 20);
	bt_assert(p23.asn = 2);
	bt_assert(p23.data = 3);

	clist l;
	bt_assert(l = -empty-);
	bt_assert(l !~ [(*,*)]);
	bt_assert((l ~ [(*,*)]) != (l !~ [(*,*)]));

	bt_assert(-empty- = -empty-);

	l.add( (one,2) );
	bt_assert(l ~ [(*,*)]);
	l.add( (2,one+2) );
	bt_assert(format(l) = "(clist (1,2) (2,3))");

	bt_assert(l.empty = -empty-);

	bt_assert((2,3) ~ l);
	bt_assert(l ~ [(1,*)]);
	bt_assert(l ~ [p23]);
	bt_assert(l ~ [(2,2..3)]);
	bt_assert(l ~ [(1,1..2)]);
	bt_assert(l ~ [(1,1)..(1,2)]);
	bt_assert(l !~ []);

	l.add((2,5));
	l.add((5,one));
	l.add((6,one));
	l.add((one,one));
	l.delete([(5,1),(6,one),(one,1)]);
	l.delete([(5,one),(6,one)]);
	l.filter([(1,*)]);
	bt_assert(l = -empty-.add((1,2)));

	bt_assert((2,3) !~ l);
	bt_assert(l !~ [(2,*)]);
	bt_assert(l !~ [(one,3..6)]);
	bt_assert(l ~ [(*,*)]);

	l.add((3,one));
	l.add((one+one+one,one+one));
	l.add((3,3));
	l.add((3,4));
	l.add((3,5));
	clist l2 = l.filter([(3,*)]);
	l.delete([(3,2..4)]);
	bt_assert(l = -empty-.add((1,2)).add((3,1)).add((3,5)));
	bt_assert(l.len = 3);

	l.add((3,2));
	l.add((4,5));
	bt_assert(l = -empty-.add((1,2)).add((3,1)).add((3,5)).add((3,2)).add((4,5)));

	bt_assert(l.len = 5);
	bt_assert(l ~ [(*,2)]);
	bt_assert(l ~ [(*,5)]);
	bt_assert(l ~ [(*, one)]);
	bt_assert(l !~ [(*,3)]);
	bt_assert(l !~ [(*,(one+6))]);
	bt_assert(l !~ [(*, (one+one+one))]);

	bt_assert(l.delete([]) = l);
	bt_assert(l.filter([]) = -empty-);

	l.delete([(*,(one+onef(3)))]);
	l.delete([(*,(4+one))]);
	bt_assert(l = -empty-.add((3,1)));

	l.delete([(*,(onef(5)))]);
	bt_assert(l = -empty-);

	l2.add((3,6));
	l = l2.filter([(3,1..4)]);
	l2.filter([(3,3..6)]);

	quad q = 2.0.1.0;
	clist ql = -empty-.add(1.0.0.1).add(q).add(3.1.0.0);
	bt_assert(delete(ql, 1.0.0.1) = -empty-.add(2.0.1.0).add(3.1.0.0));
	bt_assert(delete(ql, [2.0.0.0 .. 4.0.0.0]) = -empty-.add(1.0.0.1));
	bt_assert(filter(ql, [3.0.0.0 .. 4.0.0.0]) = -empty-.add(3.1.0.0));

	#  clist A (10,20,30)
	bt_assert(l = -empty-.add((3,1)).add((3,2)).add((3,3)).add((3,4)));
	bt_assert(format(l) = "(clist (3,1) (3,2) (3,3) (3,4))");

	#  clist B (30,40,50)
	bt_assert(l2 = -empty-.add((3,3)).add((3,4)).add((3,5)).add((3,6)));
	bt_assert(format(l2) = "(clist (3,3) (3,4) (3,5) (3,6))");

	#  clist A union B
	clist r = l.add(l2);
	bt_assert(r = -empty-.add((3,1)).add((3,2)).add((3,3)).add((3,4)).add((3,5)).add((3,6)));
	bt_assert(format(r) = "(clist (3,1) (3,2) (3,3) (3,4) (3,5) (3,6))");

	#  clist A isect B
	r = l.filter(l2);
	bt_assert(r = -empty-.add((3,3)).add((3,4)));
	bt_assert(format(r) = "(clist (3,3) (3,4))");

	#  clist A \ B
	r = l.delete(l2);
	bt_assert(r = -empty-.add((3,1)).add((3,2)));
	bt_assert(format(r) = "(clist (3,1) (3,2))");

	#  clist in c set
	r = l.filter([(3,1), (*,2)]);
	bt_assert(r = -empty-.add((3,1)).add((3,2)));
	bt_assert(format(r) = "(clist (3,1) (3,2))");

	#  minimim & maximum element
	r = -empty-.add((2,1)).add((1,3)).add((2,2)).add((3,1)).add((2,3));
	bt_assert(format(r) = "(clist (2,1) (1,3) (2,2) (3,1) (2,3))");
	bt_assert(r.min = (1,3));
	bt_assert(r.max = (3,1));

	# iteration over clist
	int x = 0;
	for pair c in r do
	    x = x + c.asn * c.asn * c.data;
	bt_assert(x = 36);
}

bt_test_suite(t_clist_new, "Testing lists of communities (new syntax)");




/*
 * 	Testing Extended Communities
 * 	----------------------------
 */

function t_ec()
{
	ec cc;
	cc = (rt, 12345, 200000);
	bt_assert(format(cc) = "(rt, 12345, 200000)");

	bt_assert(cc = (rt, 12345, 200000));
	bt_assert(cc < (rt, 12345, 200010));
	bt_assert(cc != (rt, 12346, 200000));
	bt_assert(cc != (ro, 12345, 200000));
	bt_assert(!(cc > (rt, 12345, 200010)));

	bt_assert(format((ro, 100000, 20000)) = "(ro, 100000, 20000)");
}

bt_test_suite(t_ec, "Testing extended communities");




/*
 * 	Testing Extended Community List
 * 	-------------------------------
 */

function t_eclist_old()
eclist el;
eclist el2;
eclist r;
{
	# Deprecated syntax
	el = -- empty --;
	el = add(el, (rt, 10, 20));
	el = add(el, (ro, 10.20.30.40, 100));
	el = add(el, (ro, 11.21.31.41.mask(16), 200));

	bt_assert(--empty-- = --empty--);
	bt_assert(((rt, 10, 20)) !~ --empty--);

	bt_assert(format(el) = "(eclist (rt, 10, 20) (ro, 10.20.30.40, 100) (ro, 11.21.0.0, 200))");
	bt_assert(el.len = 3);
	el = delete(el, (rt, 10, 20));
	el = delete(el, (rt, 10, 30));
	bt_assert(el = add(add(--empty--, (ro, 10.20.30.40, 100)), (ro, 11.21.0.0, 200)));
	el = add(el, (unknown 2, ten, 1));
	el = add(el, (unknown 5, ten, 1));
	el = add(el, (rt, ten, one+one));
	el = add(el, (rt, 10, 3));
	el = add(el, (rt, 10, 4));
	el = add(el, (rt, 10, 5));
	el = add(el, (generic, 0x2000a, 3*ten));
	el = delete(el, [(rt, 10, 2..ten)]);
	bt_assert(el = add(add(add(add(add(--empty--, (ro, 10.20.30.40, 100)), (ro, 11.21.0.0, 200)), (rt, 10, 1)), (unknown 5, 10, 1)), (rt, 10, 30)));

	el = filter(el, [(rt, 10, *)]);
	bt_assert(el = add(add(--empty--, (rt, 10, 1)), (rt, 10, 30)));
	bt_assert((rt, 10, 1) ~ el);
	bt_assert(el ~ [(rt, 10, ten..40)]);
	bt_assert((rt, 10, 20) !~ el);
	bt_assert((ro, 10.20.30.40, 100) !~ el);
	bt_assert(el !~ [(rt, 10, 35..40)]);
	bt_assert(el !~ [(ro, 10, *)]);
	bt_assert(el !~ []);

	el = add(el, (rt, 10, 40));
	el2 = filter(el, [(rt, 10, 20..40)] );
	el2 = add(el2, (rt, 10, 50));

	bt_assert(delete(el, []) = el);
	bt_assert(filter(el, []) = --empty--);

	#  eclist A (1,30,40)
	bt_assert(el = add(add(add(--empty--, (rt, 10, 1)), (rt, 10, 30)), (rt, 10, 40)));
	bt_assert(format(el) = "(eclist (rt, 10, 1) (rt, 10, 30) (rt, 10, 40))");

	#  eclist B (30,40,50)
	bt_assert(el2 = add(add(add(--empty--, (rt, 10, 30)), (rt, 10, 40)), (rt, 10, 50)));
	bt_assert(format(el2) = "(eclist (rt, 10, 30) (rt, 10, 40) (rt, 10, 50))");

	#  eclist A union B
	r = add(el2, el);
	bt_assert(r = add(add(add(add(--empty--, (rt, 10, 30)), (rt, 10, 40)), (rt, 10, 50)), (rt, 10, 1)));
	bt_assert(format(r) = "(eclist (rt, 10, 30) (rt, 10, 40) (rt, 10, 50) (rt, 10, 1))");

	#  eclist A isect B
	r = filter(el, el2);
	bt_assert(r = add(add(--empty--, (rt, 10, 30)), (rt, 10, 40)));
	bt_assert(format(r) = "(eclist (rt, 10, 30) (rt, 10, 40))");

	#  eclist A \ B
	r = delete(el, el2);
	bt_assert(r = add(--empty--, (rt, 10, 1)));
	bt_assert(format(r) = "(eclist (rt, 10, 1))");

	#  eclist in ec set
	r = filter(el, [(rt, 10, 1), (rt, 10, 25..30), (ro, 10, 40)]);
	bt_assert(r = add(add(--empty--, (rt, 10, 1)), (rt, 10, 30)));
	bt_assert(format(r) = "(eclist (rt, 10, 1) (rt, 10, 30))");

	#  minimim & maximum element
	r = add(add(add(add(add(--empty--, (rt, 2, 1)), (rt, 1, 3)), (rt, 2, 2)), (rt, 3, 1)), (rt, 2, 3));
	bt_assert(format(r) = "(eclist (rt, 2, 1) (rt, 1, 3) (rt, 2, 2) (rt, 3, 1) (rt, 2, 3))");
	bt_assert(r.min = (rt, 1, 3));
	bt_assert(r.max = (rt, 3, 1));

	# iteration over eclist
	int x = 0;
	for ec c in r do
	  if c > (rt, 2, 0) && c < (rt, 3, 0) then
	    x = x + 1;
	bt_assert(x = 3);
}

bt_test_suite(t_eclist_old, "Testing lists of extended communities");


function t_eclist_new()
{
	# New syntax
	eclist el;
	bt_assert(el = --empty--);
	el.add((rt, 10, 20));
	el.add((ro, 10.20.30.40, 100));
	el.add((ro, 11.21.31.41.mask(16), 200));

	bt_assert(--empty-- = --empty--);
	bt_assert(((rt, 10, 20)) !~ --empty--);

	bt_assert(format(el) = "(eclist (rt, 10, 20) (ro, 10.20.30.40, 100) (ro, 11.21.0.0, 200))");
	bt_assert(el.len = 3);
	el.delete((rt, 10, 20));
	el.delete((rt, 10, 30));
	bt_assert(el = (--empty--).add((ro, 10.20.30.40, 100)).add((ro, 11.21.0.0, 200)));

	bt_assert(el.empty = --empty--);

	el.add((unknown 2, ten, 1));
	el.add((unknown 5, ten, 1));
	el.add((rt, ten, one+one));
	el.add((rt, 10, 3));
	el.add((rt, 10, 4));
	el.add((rt, 10, 5));
	el.add((generic, 0x2000a, 3*ten));
	el.delete([(rt, 10, 2..ten)]);
	bt_assert(el = (--empty--).add((ro, 10.20.30.40, 100)).add((ro, 11.21.0.0, 200)).add((rt, 10, 1)).add((unknown 5, 10, 1)).add((rt, 10, 30)));

	el.filter([(rt, 10, *)]);
	bt_assert(el = (--empty--).add((rt, 10, 1)).add((rt, 10, 30)));
	bt_assert((rt, 10, 1) ~ el);
	bt_assert(el ~ [(rt, 10, ten..40)]);
	bt_assert((rt, 10, 20) !~ el);
	bt_assert((ro, 10.20.30.40, 100) !~ el);
	bt_assert(el !~ [(rt, 10, 35..40)]);
	bt_assert(el !~ [(ro, 10, *)]);
	bt_assert(el !~ []);

	el.add((rt, 10, 40));
	eclist el2 = el.filter([(rt, 10, 20..40)] );
	el2.add((rt, 10, 50));

	bt_assert(el.delete([]) = el);
	bt_assert(el.filter([]) = --empty--);

	#  eclist A (1,30,40)
	bt_assert(el = --empty--.add((rt, 10, 1)).add((rt, 10, 30)).add((rt, 10, 40)));
	bt_assert(format(el) = "(eclist (rt, 10, 1) (rt, 10, 30) (rt, 10, 40))");

	#  eclist B (30,40,50)
	bt_assert(el2 = --empty--.add((rt, 10, 30)).add((rt, 10, 40)).add((rt, 10, 50)));
	bt_assert(format(el2) = "(eclist (rt, 10, 30) (rt, 10, 40) (rt, 10, 50))");

	#  eclist A union B
	eclist r = el2.add(el);
	bt_assert(r = --empty--.add((rt, 10, 30)).add((rt, 10, 40)).add((rt, 10, 50)).add((rt, 10, 1)));
	bt_assert(format(r) = "(eclist (rt, 10, 30) (rt, 10, 40) (rt, 10, 50) (rt, 10, 1))");

	#  eclist A isect B
	r = el.filter(el2);
	bt_assert(r = --empty--.add((rt, 10, 30)).add((rt, 10, 40)));
	bt_assert(format(r) = "(eclist (rt, 10, 30) (rt, 10, 40))");

	#  eclist A \ B
	r = el.delete(el2);
	bt_assert(r = --empty--.add((rt, 10, 1)));
	bt_assert(format(r) = "(eclist (rt, 10, 1))");

	#  eclist in ec set
	r = el.filter([(rt, 10, 1), (rt, 10, 25..30), (ro, 10, 40)]);
	bt_assert(r = --empty--.add((rt, 10, 1)).add((rt, 10, 30)));
	bt_assert(format(r) = "(eclist (rt, 10, 1) (rt, 10, 30))");

	#  minimim & maximum element
	r = --empty--.add((rt, 2, 1)).add((rt, 1, 3)).add((rt, 2, 2)).add((rt, 3, 1)).add((rt, 2, 3));
	bt_assert(format(r) = "(eclist (rt, 2, 1) (rt, 1, 3) (rt, 2, 2) (rt, 3, 1) (rt, 2, 3))");
	bt_assert(r.min = (rt, 1, 3));
	bt_assert(r.max = (rt, 3, 1));

	# iteration over eclist
	int x = 0;
	for ec c in r do
	  if c > (rt, 2, 0) && c < (rt, 3, 0) then
	    x = x + 1;
	bt_assert(x = 3);
}

bt_test_suite(t_eclist_new, "Testing lists of extended communities");




/*
 * 	Testing sets of Extended Communities
 * 	------------------------------------
 */

define ecs2 = [(rt, ten, (one+onef(0))*10), (ro, 100000, 100..200), (rt, 12345, *)];

function t_ec_set()
ec set ecs;
{
	ecs = [(rt, ten, (one+onef(0))*10), (ro, 100000, 100..200), (rt, 12345, *)];
	bt_assert(format(ecs)  = "[(rt, 10, 20), (rt, 12345, 0)..(rt, 12345, 4294967295), (ro, 100000, 100)..(ro, 100000, 200)]");
	bt_assert(format(ecs2) = "[(rt, 10, 20), (rt, 12345, 0)..(rt, 12345, 4294967295), (ro, 100000, 100)..(ro, 100000, 200)]");

	bt_assert((rt, 10, 20) ~ ecs);
	bt_assert((ro, 100000, 100) ~ ecs);
	bt_assert((ro, 100000, 128) ~ ecs);
	bt_assert((ro, 100000, 200) ~ ecs);
	bt_assert((rt, 12345, 0) ~ ecs);
	bt_assert((rt, 12345, 200000) ~ ecs);
	bt_assert((rt, 12345, 4000000) ~ ecs);
	bt_assert((ro, 10, 20) !~ ecs);
	bt_assert((rt, 10, 21) !~ ecs);
	bt_assert((ro, 100000, 99) !~ ecs);
	bt_assert((ro, 12345, 10) !~ ecs);
	bt_assert((rt, 12346, 0) !~ ecs);
	bt_assert((ro, 0.1.134.160, 150) !~ ecs);
}

bt_test_suite(t_ec_set, "Testing sets of extended communities");




/*
 * 	Testing Large Communities
 * 	-------------------------
 */

function mktrip(int a) -> lc
{
	return (a, 2*a, 3*a);
}

function t_lclist_old()
lclist ll;
lclist ll2;
lclist r;
{
	bt_assert(---empty--- = ---empty---);
	bt_assert((10, 20, 30) !~ ---empty---);

	bt_assert((10, 20, 30).asn = 10);
	bt_assert((10, 20, 30).data1 = 20);
	bt_assert((10, 20, 30).data2 = 30);

	ll = --- empty ---;
	ll = add(ll, (ten, 20, 30));
	ll = add(ll, (1000, 2000, 3000));
	ll = add(ll, mktrip(100000));
	bt_assert(format(ll) = "(lclist (10, 20, 30) (1000, 2000, 3000) (100000, 200000, 300000))");
	bt_assert(ll.len = 3);
	bt_assert(ll = add(add(add(---empty---, (10, 20, 30)), (1000, 2000, 3000)), (100000, 200000, 300000)));

	bt_assert(mktrip(1000) ~ ll);
	bt_assert(mktrip(100) !~ ll);

	ll = --- empty ---;
	ll = add(ll, (10, 10, 10));
	ll = add(ll, (20, 20, 20));
	ll = add(ll, (30, 30, 30));

	ll2 = --- empty ---;
	ll2 = add(ll2, (20, 20, 20));
	ll2 = add(ll2, (30, 30, 30));
	ll2 = add(ll2, (40, 40, 40));

	bt_assert(delete(ll, []) = ll);
	bt_assert(filter(ll, []) = ---empty---);

	#  lclist A (10, 20, 30)
	bt_assert(format(ll) = "(lclist (10, 10, 10) (20, 20, 20) (30, 30, 30))");

	#  lclist B (20, 30, 40)
	bt_assert(format(ll2) = "(lclist (20, 20, 20) (30, 30, 30) (40, 40, 40))");

	#  lclist A union B
	r = add(ll, ll2);
	bt_assert(r = add(add(add(add(---empty---, (10,10,10)), (20,20,20)), (30,30,30)), (40,40,40)));
	bt_assert(format(r) = "(lclist (10, 10, 10) (20, 20, 20) (30, 30, 30) (40, 40, 40))");

	#  lclist A isect B
	r = filter(ll, ll2);
	bt_assert(r = add(add(---empty---, (20, 20, 20)), (30, 30, 30)));
	bt_assert(format(r) = "(lclist (20, 20, 20) (30, 30, 30))");

	#  lclist A \ B
	r = delete(ll, ll2);
	bt_assert(r = add(---empty---, (10, 10, 10)));
	bt_assert(format(r) = "(lclist (10, 10, 10))");

	#  lclist in lc set
	r = filter(ll, [(5..15, *, *), (20, 15..25, *)]);
	bt_assert(r = add(add(---empty---, (10, 10, 10)), (20, 20, 20)));
	bt_assert(format(r) = "(lclist (10, 10, 10) (20, 20, 20))");

	#  minimim & maximum element
	r = add(add(add(add(add(---empty---, (2, 3, 3)), (1, 2, 3)), (2, 3, 1)), (3, 1, 2)), (2, 1, 3));
	bt_assert(format(r) = "(lclist (2, 3, 3) (1, 2, 3) (2, 3, 1) (3, 1, 2) (2, 1, 3))");
	bt_assert(r.min = (1, 2, 3));
	bt_assert(r.max = (3, 1, 2));

	# iteration over lclist
	int x = 0;
	int y = 0;
	lc mx = (0, 0, 0);
	for lc c in r do {
	    int asn2 = c.asn * c.asn;
	    x = x + asn2 * c.data1;
	    y = y + asn2 * c.data2;
	    if c > mx then mx = c;
	}
	bt_assert(x = 39 && y = 49);
	bt_assert(mx = r.max);
}

bt_test_suite(t_lclist_old, "Testing lists of large communities");


function t_lclist_new()
{
	bt_assert(---empty--- = ---empty---);
	bt_assert((10, 20, 30) !~ ---empty---);

	bt_assert((10, 20, 30).asn = 10);
	bt_assert((10, 20, 30).data1 = 20);
	bt_assert((10, 20, 30).data2 = 30);

	lclist ll;
	bt_assert(ll = ---empty---);
	ll.add((ten, 20, 30));
	ll.add((1000, 2000, 3000));
	ll.add(mktrip(100000));

	bt_assert(ll.empty = ---empty---);
	bt_assert(format(ll) = "(lclist (10, 20, 30) (1000, 2000, 3000) (100000, 200000, 300000))");
	bt_assert(ll.len = 3);
	bt_assert(ll = ---empty---.add((10, 20, 30)).add((1000, 2000, 3000)).add((100000, 200000, 300000)));

	bt_assert(mktrip(1000) ~ ll);
	bt_assert(mktrip(100) !~ ll);

	ll.empty;
	ll.add((10, 10, 10));
	ll.add((20, 20, 20));
	ll.add((30, 30, 30));

	lclist ll2;
	ll2.add((20, 20, 20));
	ll2.add((30, 30, 30));
	ll2.add((40, 40, 40));

	bt_assert(ll.delete([]) = ll);
	bt_assert(ll.filter([]) = ---empty---);

	#  lclist A (10, 20, 30)
	bt_assert(format(ll) = "(lclist (10, 10, 10) (20, 20, 20) (30, 30, 30))");

	#  lclist B (20, 30, 40)
	bt_assert(format(ll2) = "(lclist (20, 20, 20) (30, 30, 30) (40, 40, 40))");

	#  lclist A union B
	lclist r = ll.add(ll2);
	bt_assert(r = ---empty---.add((10,10,10)).add((20,20,20)).add((30,30,30)).add((40,40,40)));
	bt_assert(format(r) = "(lclist (10, 10, 10) (20, 20, 20) (30, 30, 30) (40, 40, 40))");

	#  lclist A isect B
	r = ll.filter(ll2);
	bt_assert(r = ---empty---.add((20, 20, 20)).add((30, 30, 30)));
	bt_assert(format(r) = "(lclist (20, 20, 20) (30, 30, 30))");

	#  lclist A \ B
	r = ll.delete(ll2);
	bt_assert(r = ---empty---.add((10, 10, 10)));
	bt_assert(format(r) = "(lclist (10, 10, 10))");

	#  lclist in lc set
	r = ll.filter([(5..15, *, *), (20, 15..25, *)]);
	bt_assert(r = ---empty---.add((10, 10, 10)).add((20, 20, 20)));
	bt_assert(format(r) = "(lclist (10, 10, 10) (20, 20, 20))");

	#  minimim & maximum element
	r = ---empty---.add((2, 3, 3)).add((1, 2, 3)).add((2, 3, 1)).add((3, 1, 2)).add((2, 1, 3));
	bt_assert(format(r) = "(lclist (2, 3, 3) (1, 2, 3) (2, 3, 1) (3, 1, 2) (2, 1, 3))");
	bt_assert(r.min = (1, 2, 3));
	bt_assert(r.max = (3, 1, 2));

	# iteration over lclist
	int x = 0;
	int y = 0;
	lc mx = (0, 0, 0);
	for lc c in r do {
	    int asn2 = c.asn * c.asn;
	    x = x + asn2 * c.data1;
	    y = y + asn2 * c.data2;
	    if c > mx then mx = c;
	}
	bt_assert(x = 39 && y = 49);
	bt_assert(mx = r.max);
}

bt_test_suite(t_lclist_new, "Testing lists of large communities");




/*
 * 	Testing sets of Large Communities
 * 	---------------------------------
 */

function t_lclist_set()
lclist ll;
lc set lls;
{
	ll = --- empty ---;
	ll = add(ll, (10, 20, 30));
	ll = add(ll, (1000, 2000, 3000));
	ll = add(ll, mktrip(100000));

	bt_assert(ll ~ [(5,10,15), (10,20,30)]);
	bt_assert(ll ~ [(10,15..25,*)]);
	bt_assert(ll ~ [(ten, *, *)]);

	bt_assert(ll !~ [(5,10,15), (10,21,30)]);
	bt_assert(ll !~ [(10,21..25,*)]);
	bt_assert(ll !~ [(11, *, *)]);
	bt_assert(ll !~ []);

	lls = [(10, 10, 10), (20, 20, 15..25), (30, 30, *), (40, 35..45, *), (50, *, *), (55..65, *, *)];
	bt_assert(format(lls) = "[(10, 10, 10), (20, 20, 15)..(20, 20, 25), (30, 30, 0)..(30, 30, 4294967295), (40, 35, 0)..(40, 45, 4294967295), (50, 0, 0)..(50, 4294967295, 4294967295), (55, 0, 0)..(65, 4294967295, 4294967295)]");
	bt_assert((10, 10, 10)  ~ lls);
	bt_assert((20, 20, 25)  ~ lls);
	bt_assert((20, 20, 26) !~ lls);
	bt_assert((30, 30,  0)  ~ lls);
	bt_assert((40, 35, 40)  ~ lls);
	bt_assert((40, 34, 40) !~ lls);
	bt_assert((50,  0,  0)  ~ lls);
	bt_assert((60, 60, 60)  ~ lls);
	bt_assert((70, 60, 60) !~ lls);
}

bt_test_suite(t_lclist_set, "Testing sets of large communities");




/*
 * 	Testing Route Distinguishers
 * 	----------------------------
 */

function t_rd()
rd x;
{
	x = 12345:20000;
	bt_assert(format(x) = "12345:20000");

	bt_assert(x = 12345:20000);
	bt_assert(x < 12345:20010);
	bt_assert(x != 12346:20000);
	bt_assert(x != 2:12345:20000);
	bt_assert(!(x > 12345:200010));

	bt_assert(format(0:1:2) = "1:2");
	bt_assert(format(10.0.0.1:1000) = "10.0.0.1:1000");
	bt_assert(format(100000:20000) = "100000:20000");
	bt_assert(format(2:100000:20000) = "100000:20000");
	bt_assert(format(2:1000:1000) = "2:1000:1000");
}

bt_test_suite(t_rd, "Testing route distinguishers");




/*
 * 	Testing sets of Route Distinguishers
 * 	------------------------------------
 */

function t_rd_set()
rd set rds;
{
	rds = [];
	bt_assert(rds = []);
	bt_assert(10:20 !~ rds);

	rds = [10:20, 100000:100..100000:200];
	bt_assert(format(rds)  = "[10:20, 100000:100..100000:200]");

	bt_assert(10:20  ~ rds);
	bt_assert(10:21 !~ rds);
	bt_assert(100000:90 !~ rds);
	bt_assert(100000:100 ~ rds);
	bt_assert(100000:128 ~ rds);
	bt_assert(100000:200 ~ rds);
	bt_assert(100010:150 !~ rds);
	bt_assert(100010:150 !~ []);
}

bt_test_suite(t_rd_set, "Testing sets of route distinguishers");




/*
 * 	Testing defined() function
 * 	--------------------------
 */

function test_undef(int a)
int b;
{
	if a = 3 then {
		b = 4;
		bt_assert(defined(b));
	}
	else {
		bt_assert(!defined(b));
	}
}

function t_define()
int i;
{
	test_undef(2);
	test_undef(3);
	test_undef(2);

	bt_assert(defined(1));
	bt_assert(defined(1.2.3.4));
}

bt_test_suite(t_define, "Testing defined() function");




/*
 *	 Testing calling functions
 *	 -------------------------
 */

function callme(int arg1; int arg2) -> int
int i;
{
	case arg1 {
	1, 42: return 42;
	else: return arg1 * arg2;
	}

	return 0;
}

function callmeagain(int a; int b; int c) -> int
{
	return a + b + c;
}

function fifteen() -> int
{
	return 15;
}

function local_vars(int j)
{
	int k = 10;
	bt_assert(j = 5 && k = 10);
	{
		int j = 15;
		k = 20;
		bt_assert(j = 15 && k = 20);
	}
	bt_assert(j = 5 && k = 20);

	if j < 10 then
	{
		int j = 25;
		string k = "hello";
		bt_assert(j = 25 && k = "hello");
	}
	bt_assert(j = 5 && k = 20);

	int m = 100;
	{
		j = 35;
		int k = 40;
		bt_assert(j = 35 && k = 40 && m = 100);
	}
	bt_assert(j = 35 && k = 20 && m = 100);
}

function factorial(int x) -> int
{
	if x = 0 then return 0;
	if x = 1 then return 1;
	else return x * factorial(x - 1);
}

function fibonacci(int x) -> int
{
	if x = 0 then return 0;
	if x = 1 then return 1;
	else return fibonacci(x - 1) + fibonacci(x - 2);
}

function hanoi_init(int a; int b) -> bgppath
{
	if b = 0
	then return +empty+;
	else return prepend(hanoi_init(a + 1, b - 1), a);
}

function hanoi_solve(int n; bgppath h_src; bgppath h_dst; bgppath h_aux; bool x; bool y) -> bgppath
{
	# x -> return src or dst
	# y -> print state

	if n = 0 then { if x then return h_src; else return h_dst; }

	bgppath tmp1 = hanoi_solve(n - 1, h_src, h_aux, h_dst, true, y);
	bgppath tmp2 = hanoi_solve(n - 1, h_src, h_aux, h_dst, false, false);
	h_src = tmp1;
	h_aux = tmp2;

	int v = h_src.first;
	# bt_assert(h_dst = +empty+ || v < h_dst.first);
	h_src = delete(h_src, v);
	h_dst = prepend(h_dst, v);

	if y then
		print "move: ", v, " src: ", h_src, " dst:", h_dst, " aux:", h_aux;

	tmp1 = hanoi_solve(n - 1, h_aux, h_dst, h_src, true, y);
	tmp2 = hanoi_solve(n - 1, h_aux, h_dst, h_src, false, false);
	h_aux = tmp1;
	h_dst = tmp2;

	if x then return h_src; else return h_dst;
}

function t_call_function()
bgppath h_src;
{
	bt_assert(fifteen() = 15);

	bt_assert(callme(1, 2) = 42);
	bt_assert(callme(42, 2) = 42);

	bt_assert(callme(2, 2) = 4);
	bt_assert(callme(3, 2) = 6);
	bt_assert(callme(4, 4) = 16);
	bt_assert(callme(7, 2) = 14);
	bt_assert(callmeagain(1, 2, 3) = 6);
	local_vars(5);

	bt_assert(factorial(5) = 120);
	bt_assert(factorial(10) = 3628800);

	bt_assert(fibonacci(10) = 55);
	bt_assert(fibonacci(20) = 6765);

	h_src = hanoi_init(1, 6);
	bt_assert(format(h_src) = "(path 1 2 3 4 5 6)");
	bt_assert(hanoi_solve(6, h_src, +empty+, +empty+, false, false) = h_src);
}

bt_test_suite(t_call_function, "Testing calling functions");




/*
 * 	Test including another config file
 * 	----------------------------------
 */

function t_include()
int i;
{
  i = 1;
  include "test.conf.inc";
  bt_assert(i = 42);
}

bt_test_suite(t_include, "Testing including another config file");




/*
 * 	Test if-else statement
 * 	----------------------
 */

function t_if_else()
int i;
{
	/* Empty blocks regression test */
	if true then {}
	else {}

	if true then
		bt_assert(true);

	if false then
		bt_assert(false);
	else if true then
		bt_assert(true);
	else
		bt_assert(false);

	/* Empty blocks regression test */
	if true then {}
	else {}
}

bt_test_suite(t_if_else, "Testing if-else statement");




/*
 * 	Test for-in statement
 * 	---------------------
 */

function t_for_in()
{
	bgppath p = +empty+.prepend(5).prepend(4).prepend(3).prepend(2).prepend(1);
	bgppath q = +empty+.prepend(30).prepend(20).prepend(10);
	int a;

	# basic for loop
	a = 0;
	for int i in p do {
		a = 2 * a + i;
	}
	bt_assert(a = 57);

	# basic for loop, no braces
	a = 0;
	for int i in p do a = 2 * a + i;
	bt_assert(a = 57);

	# for loop with empty body
	a = 0;
	for int i in p do { }
	bt_assert(a = 0);

	# for loop over empty path
	a = 0;
	for int i in +empty+ do a = 1;
	bt_assert(a = 0);

	# for loop with var name shadowing
	a = 0;
	for int p in p do {
		a = 2 * a + p;
	}
	bt_assert(a = 57);

	# nested for loops
	a = 0;
	int n = 1;
	for int i in p do {
		for int j in q do {
			a = a + i * j * n;
			n = n + 1;
		}
	}
	bt_assert(a = 9300);
}

bt_test_suite(t_for_in, "Testing for-in statement");




/*
 *	Unused functions -- testing only parsing
 *	----------------------------------------
 */

function __test1()
{
	if source ~ [ RTS_BGP, RTS_STATIC ] then {
#		ospf_metric1 = 65535;
#		ospf_metric2 = 1000;
		ospf_tag = 0x12345678;
		accept;
	}
	reject;
}

function __test2()
{
	if source ~ [ RTS_BGP, RTS_STATIC ] then {
#		ospf_metric1 = 65535;
#		ospf_metric2 = 1000;
		ospf_tag = 0x12345678;
		accept;
	}
	reject;
}

filter testf
int j;
{
	print "Heya, filtering route to ", net.ip, " prefixlen ", net.len, " source ", source;
	print "This route was from ", from;
	j = 7;
	j = 17;
	if rip_metric > 15 then {
		reject "RIP Metric is more than infinity";
	}
	rip_metric = 14;
	unset(rip_metric);

	accept "ok I take that";
}

filter roa_filter
{
	if net ~ [ 10.0.0.0/8{16,24} ] || net ~ [ 2000::/3{16,96} ] then {
		accept;
	}
	reject;
}

roa4 table r4;
roa6 table r6;

protocol static
{
	roa4 { table r4; import filter roa_filter; };
	route 10.110.0.0/16 max 16 as 1000;
	route 10.120.0.0/16 max 24 as 1000;
	route 10.130.0.0/16 max 24 as 2000;
	route 10.130.128.0/18 max 24 as 3000;
}

protocol static
{
  roa6 { table r6; import filter roa_filter; };
  route 2001:0db8:85a3:8a2e::/64 max 96 as 1000;
}

function t_roa_check()
prefix pfx;
{
	bt_assert(roa_check(r4, 10.10.0.0/16, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r4, 10.0.0.0/8, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r4, 10.110.0.0/16, 1000) = ROA_VALID);
	bt_assert(roa_check(r4, 10.110.0.0/16, 2000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.110.32.0/20, 1000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.120.32.0/20, 1000) = ROA_VALID);
	bt_assert(roa_check(r4, 10.120.32.0/20, 2000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.120.32.32/28, 1000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.130.130.0/24, 1000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.130.130.0/24, 2000) = ROA_VALID);
	bt_assert(roa_check(r4, 10.130.30.0/24, 3000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.130.130.0/24, 3000) = ROA_VALID);

	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/80, 1000) = ROA_VALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/97, 1000) = ROA_INVALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e::/64, 1000) = ROA_VALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3::/48, 1000) = ROA_UNKNOWN);

	bt_assert(roa_check(r4, 10.10.0.0/16, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r4, 10.0.0.0/8, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r4, 10.110.0.0/16, 1000) = ROA_VALID);
	bt_assert(roa_check(r4, 10.110.0.0/16, 2000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.110.32.0/20, 1000) = ROA_INVALID);
	bt_assert(roa_check(r4, 10.120.32.0/20, 1000) = ROA_VALID);

	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/80, 1000) = ROA_VALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/97, 1000) = ROA_INVALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e::/64, 1000) = ROA_VALID);
	bt_assert(roa_check(r6, 2001:0db8:85a3::/48, 1000) = ROA_UNKNOWN);

	bt_assert(roa_check(r4, 2001:0db8:85a3:8a2e:1234::/97, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/97, 1000) = ROA_INVALID);

	bt_assert(roa_check(r4, 2001:0db8:85a3:8a2e:1234::/80, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r6, 2001:0db8:85a3:8a2e:1234::/80, 1000) = ROA_VALID);
	bt_assert(roa_check(r4, 2001:0db8:85a3::/48, 1000) = ROA_UNKNOWN);
	bt_assert(roa_check(r6, 2001:0db8:85a3::/48, 1000) = ROA_UNKNOWN);

	bt_assert(10.130.130.0/24 ~ 0.0.0.0/0);
	bt_assert(2001:0db8:85a3:8a2e::/64 ~ ::/0);
	bt_assert(10.130.130.0/24 !~ ::/0);
	bt_assert(2001:0db8:85a3:8a2e::/64 !~ 0.0.0.0/0);

	pfx = 12.13.0.0/16 max 24 as 1234;
	bt_assert(pfx.len = 16);
	bt_assert(pfx.maxlen = 24);
	bt_assert(pfx.asn = 1234);

	pfx = 1000::/8 max 32 as 1234;
	bt_assert(pfx.len = 8);
	bt_assert(pfx.maxlen = 32);
	bt_assert(pfx.asn = 1234);
}

bt_test_suite(t_roa_check, "Testing ROA");




filter vpn_filter
{
	bt_assert(format(net) = "1:2 10.1.10.0/24");
	bt_assert(net.type = NET_VPN4);
	bt_assert(net.type != NET_IP4);
	bt_assert(net.type != NET_IP6);
	bt_assert(net.rd = 0:1:2);

	bool b = false;
	case (net.type) {
	  NET_IP4: print "IPV4";
	  NET_IP6: print "IPV6";
	  else: b = true;
	}
	bt_assert(b);

	bt_check_assign(from, 10.20.30.40);
	# bt_check_assign(gw, 55.55.55.44);

	bgp_community.add((3,5));
	bgp_ext_community.add((ro, 135, 999));
	bgp_large_community.add((6464156, 89646354, 8675643));

	mypath.prepend(65533);
	mylclist.add((1234, 5678, 90123));

	bgppath locpath;
	lclist loclclist;

	locpath.prepend(65533);
	loclclist.add((1234, 5678, 90123));

	accept;
}

vpn4 table v4;
vpn4 table v6;

protocol static
{
	vpn4 { table v4; import filter vpn_filter; };
	route 0:1:2 10.1.10.0/24 unreachable;
}

protocol static
{
	ipv6 { import where false; };
	route fd01::/48 unreachable;
}
